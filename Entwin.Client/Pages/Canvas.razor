@page "/canvas"
@inject IJSRuntime JS

<h3>
    <ul style="font-size: 0.8em; color: gray;">
        @foreach (var cell in cells)
        {
            <li>Box @cell.Id — X: @cell.X, Y: @cell.Y</li>
        }
    </ul>
</h3>

<div @ref="canvasRef"
     @onmousemove="OnMouseMove"
     @onmouseup="OnMouseUp"
     @onmouseleave="OnMouseUp"
     @onkeydown="HandleKeyDown"
     tabindex="0"
     style="position: relative; width: 100%; height: 80vh; border: 2px solid #444; background: #f0f0f0; user-select: none;">
    @foreach (var cell in cells)
    {
        <SimBase Id="@cell.Id" X="@cell.X" Y="@cell.Y"
        InputCount="@cell.InputCount" OutputCount="@cell.OutputCount" 
        OnStartDrag="OnStartDrag" 
        OnOutputDrag="OnOutputDrag" 
        OnInputDropped="OnInputDropped"/>
    }

    <svg style="position:absolute; top:0; left:0; width:100%; height:80vh; pointer-events:none;">
         @foreach (var conn in _connections)
        {
            var fromCell = cells.First(c => c.Id == conn.FromCellId);
            var toCell = cells.First(c => c.Id == conn.ToCellId);

            int fromX = (int)(fromCell.X + 100) + 6;
            int fromY = (int)(fromCell.Y + 8 + conn.FromOutputIndex * (100.0 / (fromCell.OutputCount + 1))) + 6;

            int toX = (int)(toCell.X) - 6;
            int toY = (int)(toCell.Y + 8 + conn.ToInputIndex * (100.0 / (toCell.InputCount + 1))) + 6;

            <DataConnection FromX="@fromX"
                FromY="@fromY"
                ToX="@toX"
                ToY="@toY"
                FromId="@conn.FromCellId"
                FromIndex="@conn.FromOutputIndex"
                ToId="@conn.ToCellId"
                ToIndex="@conn.ToInputIndex"
                IsSelected="@conn.IsSelected"
                OnSelect="@(e => SelectConnection(conn, e))" />
        }
    </svg>

    @if (_isDraggingOutput)
    {
        <svg style="position:absolute; top:0; left:0; width:100%; height:80vh; pointer-events:none;">
            <line x1="@_startPosition.X"
                  y1="@_startPosition.Y"
                  x2="@_cursorPosition.X"
                  y2="@_cursorPosition.Y"
                  stroke="black"
                  stroke-width="2" />
        </svg>
    }
</div>

@code {
    private ElementReference canvasRef;
    private DomRect canvasRectCache = new();

    public class CellModel
    {
        public int Id { get; set; }
        public double X { get; set; }
        public double Y { get; set; }
        public int InputCount { get; set; }
        public int OutputCount { get; set; }
    }
    private class Connection
    {
        public int FromCellId { get; set; }
        public int ToCellId { get; set; }
        public int FromOutputIndex { get; set; }
        public int ToInputIndex { get; set; }
        public bool IsSelected { get; set; }
    }
    private List<Connection> _connections = new();


    private List<CellModel> cells = new()
    {
        new CellModel { Id = 1, X = 50, Y = 50, OutputCount = 2, InputCount = 0 },
        new CellModel { Id = 2, X = 200, Y = 150, InputCount = 2, OutputCount = 1 }
    };

    private int? draggingCellId = null;
    private double offsetX, offsetY;

    public class DomRect
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
        public double Top { get; set; }
        public double Right { get; set; }
        public double Bottom { get; set; }
        public double Left { get; set; }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            canvasRectCache = await JS.InvokeAsync<DomRect>("getBoundingClientRect", canvasRef);
            StateHasChanged();
        }
    }

    private async Task OnStartDrag((int Id, MouseEventArgs e) args)
    {
        var (cellId, e) = args;

        if (canvasRectCache == null)
            canvasRectCache = await JS.InvokeAsync<DomRect>("getBoundingClientRect", canvasRef);

        draggingCellId = cellId;

        var relativeX = e.ClientX - canvasRectCache.Left;
        var relativeY = e.ClientY - canvasRectCache.Top;

        var cell = cells.FirstOrDefault(c => c.Id == cellId);
        if (cell != null)
        {
            offsetX = relativeX - cell.X;
            offsetY = relativeY - cell.Y;
        }
    }

    private void OnMouseMove(MouseEventArgs e)
    {
        if(_isDraggingOutput)
            GetCursorPosition(e);

        if (draggingCellId.HasValue && canvasRectCache != null)
        {
            var relativeX = e.ClientX - canvasRectCache.Left - offsetX;
            var relativeY = e.ClientY - canvasRectCache.Top - offsetY;

            var clampedX = Math.Clamp(relativeX, 0, canvasRectCache.Width - 100);
            var clampedY = Math.Clamp(relativeY, 0, canvasRectCache.Height - 100);

            var cell = cells.FirstOrDefault(c => c.Id == draggingCellId.Value);
            if (cell != null)
            {
                cell.X = Math.Round(clampedX);
                cell.Y = Math.Round(clampedY);
                StateHasChanged();
            }
        }
    }

    private void OnMouseUp(MouseEventArgs e)
    {
        draggingCellId = null;
        _isDraggingOutput = false;
    }

    private (int Id, int Index) _dragSource;
    private bool  _isDraggingOutput;
    private (int X, int Y) _cursorPosition;
    private (int X, int Y) _startPosition;
    
    private async Task OnOutputDrag((int Id, int Index, MouseEventArgs e) args)
    {
        var (cellId, outputIndex, e) = args;
        _dragSource = (cellId, outputIndex);

        if (canvasRectCache == null)
            canvasRectCache = await JS.InvokeAsync<DomRect>("getBoundingClientRect", canvasRef);

        var cell = cells.First(c => c.Id == cellId);

        var outputX = cell.X + 100 + 6;
        var spacing = 100.0 / (cell.OutputCount + 1);
        var outputY = cell.Y + 8 + outputIndex * spacing + 6;

        _startPosition = ((int)outputX, (int)outputY);
        GetCursorPosition(e);

        _isDraggingOutput = true;
    }

    private void OnInputDropped((int Id, int Index, MouseEventArgs e) args)
    {   
        if(!_isDraggingOutput)
            return;
            
        var (toCellId, toInputIndex, e) = args;

        if(_dragSource.Id == toCellId)
            return;

        if (_isDraggingOutput)
        {
            var connection = new Connection() {
                FromCellId = _dragSource.Id,
                FromOutputIndex = _dragSource.Index,
                ToCellId = toCellId,
                ToInputIndex = toInputIndex,
                IsSelected = false
            };

            _connections.Add(connection);

            _isDraggingOutput = false;
        }

    }

    private void SelectConnection(Connection conn, MouseEventArgs e)
    {
        bool shiftHeld = e.ShiftKey;

        if (!shiftHeld)
        {
            foreach (var c in _connections)
                c.IsSelected = false;
        }

        conn.IsSelected = !conn.IsSelected;
    }

    private void HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Delete")
        {
            _connections.RemoveAll(c => c.IsSelected);
            StateHasChanged();
        }
    }

    private void GetCursorPosition(MouseEventArgs e){
        var relativeX = e.ClientX - canvasRectCache.Left;
        var relativeY = e.ClientY - canvasRectCache.Top;

        _cursorPosition.X = (int)relativeX;
        _cursorPosition.Y = (int)relativeY;
    }

    

}
