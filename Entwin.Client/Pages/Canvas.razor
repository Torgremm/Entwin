@page "/canvas"
@inject IJSRuntime JS

<h3>
    <ul style="font-size: 0.8em; color: gray;">
        @foreach (var cell in cells)
        {
            <li>Box @cell.Id — X: @cell.X, Y: @cell.Y</li>
        }
    </ul>
</h3>

<div @ref="canvasRef"
     @onmousemove="OnMouseMove"
     @onmouseup="OnMouseUp"
     @onmouseleave="OnMouseUp"
     style="position: relative; width: 100%; height: 80vh; border: 2px solid #444; background: #f0f0f0; user-select: none;">
    @foreach (var cell in cells)
    {
        <SimBase Id="@cell.Id" X="@cell.X" Y="@cell.Y" OnStartDrag="OnStartDrag" />
    }
</div>

@code {
    private ElementReference canvasRef;
    private DomRect canvasRectCache = new();

    private List<Cell> cells = new()
    {
        new Cell { Id = 1, X = 50, Y = 50 },
        new Cell { Id = 2, X = 200, Y = 150 }
    };

    private int? draggingCellId = null;
    private double offsetX, offsetY;

    public class DomRect
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
        public double Top { get; set; }
        public double Right { get; set; }
        public double Bottom { get; set; }
        public double Left { get; set; }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            canvasRectCache = await JS.InvokeAsync<DomRect>("getBoundingClientRect", canvasRef);
            StateHasChanged();
        }
    }

    private async Task OnStartDrag((int Id, MouseEventArgs e) args)
    {
        var (cellId, e) = args;

        if (canvasRectCache == null)
            canvasRectCache = await JS.InvokeAsync<DomRect>("getBoundingClientRect", canvasRef);

        draggingCellId = cellId;

        var relativeX = e.ClientX - canvasRectCache.Left;
        var relativeY = e.ClientY - canvasRectCache.Top;

        var cell = cells.FirstOrDefault(c => c.Id == cellId);
        if (cell != null)
        {
            offsetX = relativeX - cell.X;
            offsetY = relativeY - cell.Y;
        }
    }

    private void OnMouseMove(MouseEventArgs e)
    {
        if (draggingCellId.HasValue && canvasRectCache != null)
        {
            var relativeX = e.ClientX - canvasRectCache.Left - offsetX;
            var relativeY = e.ClientY - canvasRectCache.Top - offsetY;

            var clampedX = Math.Clamp(relativeX, 0, canvasRectCache.Width - 100);
            var clampedY = Math.Clamp(relativeY, 0, canvasRectCache.Height - 100);

            var cell = cells.FirstOrDefault(c => c.Id == draggingCellId.Value);
            if (cell != null)
            {
                cell.X = Math.Round(clampedX);
                cell.Y = Math.Round(clampedY);
                StateHasChanged();
            }
        }
    }

    private void OnMouseUp(MouseEventArgs e)
    {
        draggingCellId = null;
    }

    class Cell
    {
        public int Id { get; set; }
        public double X { get; set; }
        public double Y { get; set; }
    }
}
