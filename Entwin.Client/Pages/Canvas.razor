@page "/canvas"
@using Microsoft.AspNetCore.Components.Web
@inject IJSRuntime JS

<h3>
    <ul style="font-size: 0.8em; color: gray;">
        @foreach (var cell in cells)
        {
            <li>Box @cell.Id — X: @cell.X, Y: @cell.Y</li>
        }
    </ul>
</h3>

<div @ref="canvasRef"
     @onmousemove="OnMouseMove"
     @onmouseup="OnMouseUp"
     @onmouseleave="OnMouseUp"
     style="position: relative; width: 100%; height: 80vh; border: 2px solid #444; background: #f0f0f0; user-select: none;">
    
    @foreach (var cell in cells)
    {
        <SimBase Id="@cell.Id"
                 X="@cell.X"
                 Y="@cell.Y"
                 OnStartDrag="OnMouseDown" />
    }
</div>

@code {
    private ElementReference canvasRef;
    private DomRect canvasRectCache;
    private double offsetX, offsetY;
    private int? draggingCellId = null;

    private List<Cell> cells = new()
    {
        new Cell { Id = 1, X = 50, Y = 50 },
        new Cell { Id = 2, X = 200, Y = 150 }
    };

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            canvasRectCache = await JS.InvokeAsync<DomRect>("getBoundingClientRect", canvasRef);
            StateHasChanged();
        }
    }

    private async Task OnMouseDown((int Id, MouseEventArgs e) args)
    {
        var (cellId, e) = args;

        if (canvasRectCache == null)
            canvasRectCache = await JS.InvokeAsync<DomRect>("getBoundingClientRect", canvasRef);
            
        draggingCellId = cellId;
    
        var relativeX = e.ClientX - canvasRectCache.Left;
        var relativeY = e.ClientY - canvasRectCache.Top;
    
        var cell = cells.First(c => c.Id == cellId);
    
        offsetX = relativeX - cell.X;
        offsetY = relativeY - cell.Y;
    }

    private void OnMouseMove(MouseEventArgs e)
    {
        if (draggingCellId.HasValue && canvasRectCache != null)
        {
            var relativeX = e.ClientX - canvasRectCache.Left - offsetX;
            var relativeY = e.ClientY - canvasRectCache.Top - offsetY;

            var clampedX = Math.Clamp(relativeX, 0, canvasRectCache.Width - 100);
            var clampedY = Math.Clamp(relativeY, 0, canvasRectCache.Height - 100);

            var cell = cells.First(c => c.Id == draggingCellId.Value);
            cell.X = Math.Round(clampedX);
            cell.Y = Math.Round(clampedY);

            StateHasChanged();
        }
    }

    private void OnMouseUp(MouseEventArgs e)
    {
        draggingCellId = null;
    }

    public class Cell
    {
        public int Id { get; set; }
        public double X { get; set; }
        public double Y { get; set; }
    }

    public class DomRect
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
        public double Top { get; set; }
        public double Right { get; set; }
        public double Bottom { get; set; }
        public double Left { get; set; }
    }

    public class MouseCoords
    {
        public double ClientX { get; set; }
        public double ClientY { get; set; }
    }
}
