@using Entwin.Client.Components.Editors
@page "/canvas"
@inject HttpClient Http
@inject IJSRuntime JS
@inject SimulationState SimState


<h3>
    <ul style="font-size: 0.8em; color: gray;">
        nothing
    </ul>
</h3>

<div @ref="canvasRef"
    @onmousemove="OnMouseMove"
    @onmouseup="OnMouseUp"
    @onmouseleave="OnMouseUp"
    @onkeydown="HandleKeyDown"
    @oncontextmenu:preventDefault="true"
    @oncontextmenu="ShowContextMenu"
    @onclick="OnCanvasClick"
    tabindex="0"
    style="position: relative; width: 100%; height: 80vh; border: 2px solid #444; background: #f0f0f0; user-select: none;">
    @foreach (var cell in _cells)
    {
        <SimBase
        ComponentData="cell"
        OnSelect="@(e => SelectComponent(cell, e))"
        OnStartDrag="OnStartDrag"
        OnOutputDrag="OnOutputDrag"
        OnInputDropped="OnInputDropped"
        OnComponentSelected="ShowEditor"
        />
    }

    @if (showContextMenu)
    {
        <div style="position:absolute; left:@(_cursorPosition.X)px; top:@(_cursorPosition.Y)px; background:#fff; border:1px solid #ccc; padding:5px; user-select:none;">
            <div style="position: relative; display: inline-block;"
                 @onmouseenter="() => showSubMenu = true"
                 @onmouseleave="() => showSubMenu = false">
                <span style="cursor:pointer;">
                    Add ▸
                </span>

                @if (showSubMenu)
                {
                    <div style="position:absolute; left:100%; top:0; background:#eee; border:1px solid #aaa; padding:5px; z-index:1000; white-space: nowrap;">
                        @foreach (var comp in availableComponents)
                        {
                            <div style="padding:2px 10px; cursor:pointer;"
                                 @onclick="() => AddComponent(comp.ComponentType)">
                                @comp.Name
                            </div>
                        }
                    </div>
                }
                <div style="padding:2px 10px; cursor:pointer;"
                    @onclick="() => RunSimulation()">
                    Run
                </div>
            </div>
        </div>
    }




    <svg style="position:absolute; top:0; left:0; width:100%; height:80vh; pointer-events:none;">
         @foreach (var conn in _connections)
        {
            var fromCell = _cells.First(c => c.Id == conn.FromCellId);
            var toCell = _cells.First(c => c.Id == conn.ToCellId);

            int fromX = (int)(fromCell.X + 100) + 6;
            int fromY = (int)(fromCell.Y + 8 + conn.FromOutputIndex * (100.0 / (fromCell.OutputCount + 1))) + 6;

            int toX = (int)(toCell.X) - 6;
            int toY = (int)(toCell.Y + 8 + conn.ToInputIndex * (100.0 / (toCell.InputCount + 1))) + 6;

            <DataConnection FromX="@fromX"
                FromY="@fromY"
                ToX="@toX"
                ToY="@toY"
                FromId="@conn.FromCellId"
                FromIndex="@conn.FromOutputIndex"
                ToId="@conn.ToCellId"
                ToIndex="@conn.ToInputIndex"
                IsSelected="@conn.IsSelected"
                IsActive="@ConnectionValue(conn.FromCellId,conn.FromOutputIndex,conn.ToCellId,conn.ToInputIndex)"
                OnSelect="@(e => SelectConnection(conn, e))" />
        }
    </svg>

    @if (_isDraggingOutput)
    {
        <svg style="position:absolute; top:0; left:0; width:100%; height:80vh; pointer-events:none;">
            <line x1="@_startPosition.X"
                  y1="@_startPosition.Y"
                  x2="@_cursorPosition.X"
                  y2="@_cursorPosition.Y"
                  stroke="black"
                  stroke-width="2" />
        </svg>
    }
    @if (showSignalPopup && selectedValues?.Any() == true)
    {
        <div style="
            position: absolute;
            left: @(_cursorPosition.X)px;
            top: @(_cursorPosition.Y)px;
            width: 400px;
            height: 300px;
            background: white;
            border: 1px solid #ccc;
            padding: 10px;
            z-index: 5000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            overflow: hidden;
            user-select: none;
            pointer-events: auto;">
            <PlotComponent 
                YValues="selectedValues" 
                XValues="selectedTimes" 
                Label="Signal" />
            <button @onclick="() => showSignalPopup = false" style="margin-top: 5px;">Close</button>
        </div>
    }

</div>
@if (_selectedComponent != null)
{
    <div style="
        position: absolute;
        top: @(_selectedComponent.Y - 200 > 0 ? (int)_selectedComponent.Y - 200 : (int)_selectedComponent.Y + 230)px;
        left: @((int)_selectedComponent.X + 100)px;
        z-index: 2000;
        width: 300px;
        max-height: 90vh;
        background: white;
        border: 1px solid #ccc;
        border-radius: 6px;
        padding: 10px;
        overflow-y: auto;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        pointer-events: auto;">
        
        <DynamicComponent Type="@GetEditorType(_selectedComponent)" Parameters="GetParameters(_selectedComponent)" />
    </div>
}



@code {
    private ElementReference canvasRef;
    private DomRect canvasRectCache = new();
    private SimulationResultDTO? _simulationResult;

    private readonly List<(string Name, Type ComponentType)> availableComponents = new()
    {
        ("Constant", typeof(Constant)),
        ("Gain", typeof(Gain)),
        ("CustomFunction", typeof(CustomFunction)),
        ("Step", typeof(Components.Step)),
        ("Sum", typeof(Sum)),
        ("TransferFunction", typeof(TransferFunction))
    };

    private List<BaseComponentData> _cells = new();

    private class Connection
    {
        public int FromCellId { get; set; }
        public int ToCellId { get; set; }
        public int FromOutputIndex { get; set; }
        public int ToInputIndex { get; set; }
        public bool IsSelected { get; set; }
    }
    private List<Connection> _connections = new();

    

    private int? draggingCellId = null;
    private double offsetX, offsetY;

    public class DomRect
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
        public double Top { get; set; }
        public double Right { get; set; }
        public double Bottom { get; set; }
        public double Left { get; set; }
    }

    private async Task RunSimulation()
    {
        try
        {
            var request = new SimulationRequestDTO
            {
                Components = _cells.Select(cell =>
                {
                    if (cell is ISimulatableComponent dtoComponent)
                        return dtoComponent.ToDTO();
                    else
                        throw new InvalidOperationException("Component does not support DTO conversion.");
                }).ToList(),

                Connections = _connections.Select(conn => new ConnectionDTO
                {
                    From = conn.FromCellId,
                    From_Position = conn.FromOutputIndex,
                    To = conn.ToCellId,
                    To_Position = conn.ToInputIndex
                }).ToList()
            };

            var response = await Http.PostAsJsonAsync("api/simulation/simulate-step", request);

            if (!response.IsSuccessStatusCode)
            {
                var msg = await response.Content.ReadAsStringAsync();
                Console.Error.WriteLine($"Simulation failed: {response.StatusCode} - {msg}");
                return;
            }

            var result = await response.Content.ReadFromJsonAsync<SimulationResultDTO>();
            if (result is null)
            {
                Console.Error.WriteLine("Simulation returned null result.");
                return;
            }

            Console.WriteLine("Simulation succeeded.");
            SimState.LastResult = result;

            StateHasChanged();        
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Simulation exception: {ex.Message}");
        }
    }



    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            canvasRectCache = await JS.InvokeAsync<DomRect>("getBoundingClientRect", canvasRef);
            StateHasChanged();
        }
    }

    private async Task OnStartDrag((int Id, MouseEventArgs e) args)
    {
        var (cellId, e) = args;

        if (canvasRectCache == null)
            canvasRectCache = await JS.InvokeAsync<DomRect>("getBoundingClientRect", canvasRef);

        draggingCellId = cellId;

        var relativeX = e.ClientX - canvasRectCache.Left;
        var relativeY = e.ClientY - canvasRectCache.Top;

        var cell = _cells.FirstOrDefault(c => c.Id == cellId);
        if (cell != null)
        {
            offsetX = relativeX - cell.X;
            offsetY = relativeY - cell.Y;
        }
    }

    private void OnMouseMove(MouseEventArgs e)
    {
        if(_isDraggingOutput)
            GetCursorPosition(e);

        if (draggingCellId.HasValue && canvasRectCache != null)
        {
            var relativeX = e.ClientX - canvasRectCache.Left - offsetX;
            var relativeY = e.ClientY - canvasRectCache.Top - offsetY;

            var clampedX = Math.Clamp(relativeX, 0, canvasRectCache.Width - 100);
            var clampedY = Math.Clamp(relativeY, 0, canvasRectCache.Height - 100);

            var cell = _cells.FirstOrDefault(c => c.Id == draggingCellId.Value);
            if (cell != null)
            {
                cell.X = Math.Round(clampedX);
                cell.Y = Math.Round(clampedY);
                StateHasChanged();
            }
        }
    }

    private void OnMouseUp(MouseEventArgs e)
    {
        draggingCellId = null;
        _isDraggingOutput = false;
    }

    private (int Id, int Index) _dragSource;
    private bool  _isDraggingOutput;
    private (int X, int Y) _cursorPosition;
    private (int X, int Y) _startPosition;

    private BaseComponentData? _selectedComponent;
    
    private async Task OnOutputDrag((int Id, int Index, MouseEventArgs e) args)
    {
        var (cellId, outputIndex, e) = args;
        _dragSource = (cellId, outputIndex);

        if (canvasRectCache == null)
            canvasRectCache = await JS.InvokeAsync<DomRect>("getBoundingClientRect", canvasRef);

        var cell = _cells.First(c => c.Id == cellId);

        var outputX = cell.X + 100 + 6;
        var spacing = 100.0 / (cell.OutputCount + 1);
        var outputY = cell.Y + 8 + outputIndex * spacing + 6;

        _startPosition = ((int)outputX, (int)outputY);
        GetCursorPosition(e);

        _isDraggingOutput = true;
    }

    private void OnInputDropped((int Id, int Index, MouseEventArgs e) args)
    {   
        if(!_isDraggingOutput)
            return;
            
        var (toCellId, toInputIndex, e) = args;

        if(_dragSource.Id == toCellId)
            return;

        if(_connections.Any(c => c.ToCellId == toCellId && c.ToInputIndex == toInputIndex))
            return;

        if (_isDraggingOutput)
        {
            var connection = new Connection() {
                FromCellId = _dragSource.Id,
                FromOutputIndex = _dragSource.Index,
                ToCellId = toCellId,
                ToInputIndex = toInputIndex,
                IsSelected = false
            };

            _connections.Add(connection);

            _isDraggingOutput = false;
        }

    }

    private Dictionary<string, object> GetParameters(BaseComponentData component)
    {
        if (component == null)
        return new Dictionary<string, object>();

        return new Dictionary<string, object>
        {
            ["Component"] = component,
            ["OnClose"] = EventCallback.Factory.Create(this, () => _selectedComponent = null)
        };
    }

    private Type GetEditorType(BaseComponentData component)
    {
        return component switch
        {
            TransferFunction => typeof(TransferFunctionEditor),
            Gain => typeof(GainEditor),
            Constant => typeof(ConstantEditor),
            Components.Step => typeof(StepEditor),
            Sum => typeof(SumEditor),
            CustomFunction => typeof(CustomFunctionEditor),
            _ => throw new ArgumentException($"No editor type defined for component of type {component.GetType().Name}")
        };
    }

    private void ShowEditor(BaseComponentData component)
    {
        _selectedComponent = component;
    }



    private void SelectConnection(Connection conn, MouseEventArgs e)
    {
        bool shiftHeld = e.ShiftKey;

        if (!shiftHeld)
        {
            foreach (var c in _connections)
                c.IsSelected = false;
            foreach (var c in _cells)
                c.IsSelected = false;
        }

        conn.IsSelected = !conn.IsSelected;

        if (conn.IsSelected)
        {
            var key = new SignalKey(
                conn.FromCellId,
                conn.FromOutputIndex,
                conn.ToCellId,
                conn.ToInputIndex
            );

            ShowSignal(key);
        }
    }

    private void SelectComponent(BaseComponentData cell, MouseEventArgs e)
    {
        bool shiftHeld = e.ShiftKey;

        if (!shiftHeld)
        {
            foreach (var c in _cells)
                c.IsSelected = false;
            foreach (var c in _connections)
                c.IsSelected = false;
        }
        cell.IsSelected = !cell.IsSelected;

        if(cell.IsSelected)
            _selectedComponent = cell;

        
    }

    private void OnCanvasClick(MouseEventArgs e)
    {
        if (e.Button == 0)
        {
            foreach (var conn in _connections)
            {
                conn.IsSelected = false;
            }
            foreach (var cell in _cells)
            {
                cell.IsSelected = false;
            }

            _selectedComponent = null;
            showContextMenu = false;
            showSignalPopup = false;
            StateHasChanged();
        }
    }


    private bool showContextMenu = false;
    private bool showSubMenu = false;
    private void ShowContextMenu(MouseEventArgs e)
    {
        GetCursorPosition(e);
        showContextMenu = true;
    }
    private void AddComponent(Type componentType)
    {
        var newId = _cells.Any() ? _cells.Max(c => c.Id) + 1 : 1;

        if (Activator.CreateInstance(componentType) is BaseComponentData newCell)
        {
            newCell.Id = newId;
            newCell.X = _cursorPosition.X;
            newCell.Y = _cursorPosition.Y;

            _cells.Add(newCell);
        }

        showContextMenu = false;
        showSubMenu = false;
        StateHasChanged();
    }


    private void HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Delete")
        {
            _connections.RemoveAll(c => c.IsSelected);

            var selectedCellIds = _cells.Where(c => c.IsSelected).Select(c => c.Id).ToHashSet();
            _connections.RemoveAll(c => selectedCellIds.Contains(c.FromCellId) || selectedCellIds.Contains(c.ToCellId));
            _cells.RemoveAll(c => c.IsSelected);

            StateHasChanged();
        }
    }

    private void GetCursorPosition(MouseEventArgs e){
        var relativeX = e.ClientX - canvasRectCache.Left;
        var relativeY = e.ClientY - canvasRectCache.Top;

        _cursorPosition.X = (int)relativeX;
        _cursorPosition.Y = (int)relativeY;
    }

    private bool ConnectionValue(int from, int from_p, int to, int to_p){
        var key = new SignalKey(
            from,
            from_p,
            to,
            to_p
        );
        return SimState.LastResult?.Signals.ContainsKey(key) == true;
    }

    private bool showSignalPopup;
    private List<double> selectedValues;
    private List<double> selectedTimes;
    private SignalKey selectedSignalKey;

    private void ShowSignal(SignalKey key)
    {
        if (SimState.LastResult?.Signals.TryGetValue(key, out var signalValues) ?? false)
        {
            selectedTimes = Enumerable.Range(0, signalValues.Count).Select(i => i * 0.1).ToList(); //FIX TIMESTEP
            selectedValues = new List<double>(signalValues);

            Console.WriteLine($"ShowSignal called with {selectedValues.Count} values.");
            selectedSignalKey = key;
            showSignalPopup = true;
        }
    }


}
